from typing import List, Dict, Tuple
from collections import deque
from graph_abc import Graph # Assume this import works


class GraphAlgorithms:
    # ... (docstring remains the same) ...

    @staticmethod
    def bfs(graph: Graph, start: int) -> List[int]:
        """Breadth-First Search (BFS) starting from vertex start."""
        if not (0 <= start < graph.vertices):
            raise IndexError(f"start vertex {start} is out of range [0, {graph.vertices - 1}]")

        adj = graph.get_adjacency_list()
        visited = [False] * graph.vertices
        queue = deque([start])
        visited[start] = True # Помечаем как посещенную при добавлении в очередь
        visit_order = []

        while queue:
            u = queue.popleft()
            visit_order.append(u)

            # Соседи уже отсортированы в get_adjacency_list()
            for v, _ in adj[u]:
                if not visited[v]:
                    visited[v] = True
                    queue.append(v)
        
        return visit_order

    @staticmethod
    def dfs(graph: Graph, start: int) -> List[int]:
        """Depth-First Search (DFS) starting from vertex start."""
        if not (0 <= start < graph.vertices):
            raise IndexError(f"start vertex {start} is out of range [0, {graph.vertices - 1}]")

        adj = graph.get_adjacency_list()
        visited = [False] * graph.vertices
        visit_order = []
        
        # Рекурсивная реализация DFS (Preorder traversal)
        def _dfs_recursive(u: int):
            visited[u] = True
            visit_order.append(u)
            
            # Соседи уже отсортированы в adj
            for v, _ in adj[u]:
                if not visited[v]:
                    _dfs_recursive(v)

        _dfs_recursive(start)
        
        return visit_order
        
    @staticmethod
    def connected_components(graph: Graph) -> List[List[int]]:
        """Find connected (or weakly connected for directed) components."""
        n = graph.vertices
        visited = [False] * n
        components = []

        # Построение временного неориентированного графа для ВСС/СС
        temp_adj: Dict[int, List[int]] = {i: [] for i in range(n)}
        
        # Получаем adj_list, в котором соседи уже отсортированы
        adj_list = graph.get_adjacency_list() 
        
        for u in range(n):
            for v, _ in adj_list[u]:
                # Добавляем ребро u-v
                if v not in temp_adj[u]:
                    temp_adj[u].append(v)
                
                # Добавляем симметричное ребро v-u (для ВСС или СС)
                if u not in temp_adj[v]:
                    temp_adj[v].append(u)
        
        # Для детерминизма: сортируем списки соседей (если не сортировались)
        # В данном случае, это необходимо для гарантированного порядка обхода в BFS/DFS
        for u in range(n):
            temp_adj[u].sort()
        
        
        for i in range(n):
            if not visited[i]:
                component = []
                queue = deque([i]) # Используем BFS для поиска компонента
                visited[i] = True
                
                while queue:
                    u = queue.popleft()
                    component.append(u)
                    
                    for v in temp_adj[u]:
                        if not visited[v]:
                            visited[v] = True
                            queue.append(v)
                
                # Сортировка вершин внутри компонента
                component.sort()
                components.append(component)

        # Сортировка компонентов по наименьшей вершине
        components.sort(key=lambda c: c[0])
        return components


    @staticmethod
    def components_with_stats(graph: Graph) -> List[Dict[str, object]]:
        """Return statistics for each connected component."""
        comps = GraphAlgorithms.connected_components(graph)
        stats_list = []
        adj = graph.get_adjacency_list()
        
        # Отображение вершины на Set компонента для быстрого поиска принадлежности
        comp_sets = [set(c) for c in comps]

        for component_vertices in comps:
            node_count = len(component_vertices)
            smallest_vertex = component_vertices[0]
            edge_count = 0
            comp_set = set(component_vertices)
            
            if graph.directed:
                # Направленный граф: считаем рёбра (u -> v), где u и v в компоненте
                for u in component_vertices:
                    for v, _ in adj[u]:
                        if v in comp_set:
                            edge_count += 1
            else:
                # Ненаправленный граф: считаем рёбра {u, v} только один раз (u < v)
                for u in component_vertices:
                    for v, _ in adj[u]:
                        if u < v and v in comp_set:
                            edge_count += 1

            stats = {
                "vertices": component_vertices,
                "node_count": node_count,
                "edge_count": edge_count,
                "smallest_vertex": smallest_vertex
            }
            stats_list.append(stats)

        # Сортировка по (-node_count, -edge_count, smallest_vertex)
        stats_list.sort(key=lambda s: (-s["node_count"], -s["edge_count"], s["smallest_vertex"]))

        return stats_list
